/*
 * amplifi-platform
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://github.com/OpenAPITools/openapi-generator
 *
 * Generator version: 7.11.0-SNAPSHOT
 */

import http from "k6/http";
// import * as faker from "faker/locale/en_US";
import faker from "https://cdnjs.cloudflare.com/ajax/libs/Faker/3.1.0/faker.min.js";
import { uuidv4 } from "https://jslib.k6.io/k6-utils/1.4.0/index.js";
import { group, check, sleep, fail } from "k6";
import encoding from "k6/encoding";

const BASE_URL = "http://dev-api.dataamplifi.com";
// Sleep duration between successive requests.
// You might want to edit the value of this variable or remove calls to the sleep function on the script.
const SLEEP_DURATION = 0.1;
// Global variables should be initialized.
const USERNAME = "";
const PASSWORD = "";
const socratesFile = open("./test-data/Socrates.pdf", "b");

let scenarios = {
  listUsers_constant: {
    executor: "per-vu-iterations",
    vus: 5,
    iterations: 2,
    maxDuration: "30s",
    tags: { test_type: "listUsers" }, // different extra metric tags for this scenario
    exec: "UsersList", // Test scenario function to call
  },
  OrganizationCRUD_constant: {
    executor: "per-vu-iterations",
    vus: 5,
    iterations: 2,
    maxDuration: "30s",
    tags: { test_type: "OrganizationCRUD" }, // different extra metric tags for this scenario
    exec: "OrganizationCRUD", // Test scenario function to call
  },
  WorkspaceCRUD_constant: {
    executor: "per-vu-iterations",
    vus: 5,
    iterations: 2,
    maxDuration: "30s",
    tags: { test_type: "WorkspaceCRUD" }, // different extra metric tags for this scenario
    exec: "WorkspaceCRUD", // Test scenario function to call
  },
  DatasetCRUD_constant: {
    executor: "per-vu-iterations",
    vus: 5,
    iterations: 2,
    maxDuration: "30s",
    tags: { test_type: "DatasetCRUD" }, // different extra metric tags for this scenario
    exec: "DatasetCRUD", // Test scenario function to call
  },
  SourceCRUD_constant: {
    executor: "per-vu-iterations",
    vus: 5,
    iterations: 2,
    maxDuration: "30s",
    tags: { test_type: "SourceCRUD" }, // different extra metric tags for this scenario
    exec: "SourceCRUD", // Test scenario function to call
  },
  DestinationCRUD_constant: {
    executor: "per-vu-iterations",
    vus: 5,
    iterations: 2,
    maxDuration: "30s",
    tags: { test_type: "DestinationCRUD" }, // different extra metric tags for this scenario
    exec: "DestinationCRUD", // Test scenario function to call
  },
  UploadFile_constant: {
    executor: "per-vu-iterations",
    vus: 5,
    iterations: 1,
    maxDuration: "30s",
    tags: { test_type: "UploadFile" }, // different extra metric tags for this scenario
    exec: "UploadFile", // Test scenario function to call
  },
  IngestOneFile_constant: {
    executor: "per-vu-iterations",
    vus: 5,
    iterations: 1,
    maxDuration: "30s",
    tags: { test_type: "IngestOneFile" }, // different extra metric tags for this scenario
    exec: "IngestOneFile", // Test scenario function to call
  },
  GetAuditLogs_constant: {
    executor: "per-vu-iterations",
    vus: 5,
    iterations: 1,
    maxDuration: "30s",
    tags: { test_type: "GetAuditLogs" }, // different extra metric tags for this scenario
    exec: "GetAuditLogs", // Test scenario function to call
  },
  WorkflowCRUD_constant: {
    executor: "per-vu-iterations",
    vus: 5,
    iterations: 1,
    maxDuration: "30s",
    tags: { test_type: "WorkflowCRUD" }, // different extra metric tags for this scenario
    exec: "WorkflowCRUD", // Test scenario function to call
  },

  // Constant Arrival Rates
  DatasetCRUD_ConstantRate_5: {
    executor: "constant-arrival-rate",
    rate: 5,
    timeUnit: "1s",
    duration: "2m",
    preAllocatedVUs: 25,
    tags: { test_type: "DatasetCRUD" }, // different extra metric tags for this scenario
    exec: "DatasetCRUD", // Test scenario function to call
  },
  IngestOneFile_ConstantRate_5: {
    executor: "constant-arrival-rate",
    rate: 5,
    timeUnit: "1s",
    duration: "2m",
    preAllocatedVUs: 25,
    tags: { test_type: "IngestOneFile" }, // different extra metric tags for this scenario
    exec: "IngestOneFile", // Test scenario function to call
  },
  IngestOneFile_ConstantRate_10: {
    executor: "constant-arrival-rate",
    rate: 10,
    timeUnit: "1s",
    duration: "2m",
    preAllocatedVUs: 200,
    tags: { test_type: "IngestOneFile" }, // different extra metric tags for this scenario
    exec: "IngestOneFile", // Test scenario function to call
  },
  AllApis_ConstantRate_1: {
    executor: "constant-arrival-rate",
    rate: 1,
    timeUnit: "1s",
    duration: "1m",
    preAllocatedVUs: 50,
    tags: { test_type: "AllApis" }, // different extra metric tags for this scenario
    exec: "AllApis", // Test scenario function to call
  },
  AllApis_ConstantRate_5: {
    executor: "constant-arrival-rate",
    rate: 5,
    timeUnit: "1s",
    duration: "1m",
    preAllocatedVUs: 100,
    tags: { test_type: "AllApis" }, // different extra metric tags for this scenario
    exec: "AllApis", // Test scenario function to call
  },
};

export let options = {
  scenarios: {}, // to be set later
  // ... whatever other script options you have
};

if (__ENV.scenario) {
  // Use just a single scenario if `--env scenario=whatever` is used
  options.scenarios[__ENV.scenario] = scenarios[__ENV.scenario];
} else {
  // Use all scenrios
  options.scenarios = scenarios;
}

// set the authorization header on the session for the subsequent requests
const requestConfigWithTag = (authToken, tag) => ({
  headers: {
    Authorization: `Bearer ${authToken}`,
    "Content-Type": "application/json",
    Accept: "application/json",
  },
  tags: Object.assign(
    {},
    {
      name: "UNKNOWN_API",
      path: "UNKNOWN_PATH",
    },
    tag
  ),
});

const requestConfigWithHeadersAndTag = (authToken, headers, tag) => ({
  headers: Object.assign(
    {},
    {
      Authorization: `Bearer ${authToken}`,
      Accept: "application/json",
    },
    headers
  ),
  tags: Object.assign(
    {},
    {
      name: "UNKNOWN_API",
      path: "UNKNOWN_PATH",
    },
    tag
  ),
});

// Register a new user and retrieve authentication token for subsequent API requests
export function setup() {
  let params = {
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Accept: "application/json",
    },
  };
  let body = {
    username: USERNAME,
    password: PASSWORD,
  };
  const res = http.post(`${BASE_URL}/api/v1/login/access-token`, body, params);

  check(res, { "logged in user": (r) => r.status === 200 });

  // console.log(`response:${res.json()}`);
  const authToken = res.json("access_token");
  check(authToken, { "logged in successfully": () => authToken !== undefined });
  // console.log(`authToken:${authToken}`);
  return authToken;
}

export function UsersList(authToken) {
  group("/api/v1/user/list", () => {
    let size = "20"; // specify value as there is no example value for this parameter in OpenAPI spec
    let page = "1"; // specify value as there is no example value for this parameter in OpenAPI spec

    // Request No. 1: read_users_list_api_v1_user_list_get
    {
      let url = BASE_URL + `/api/v1/user/list?page=${page}&size=${size}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_Users",
          path: "/api/v1/user/list",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
    }
  });
}

function createOrganization(authToken) {
  let url = BASE_URL + `/api/v1/organization`;
  let body = {
    name: faker.company.companyName(),
    description: faker.lorem.sentence(),
    domain: faker.internet.domainName(),
  };

  let request = http.post(
    url,
    JSON.stringify(body),
    requestConfigWithTag(authToken, {
      name: "CREATE_Organization",
      path: "/api/v1/organization",
    })
  );

  check(request, {
    "Successful Response": (r) => r.status === 200,
  });
  sleep(SLEEP_DURATION);
  return request.json().data.id;
}

function getUserOrganization(authToken) {
  let url = BASE_URL + `/api/v1/user`;

  let request = http.get(
    url,
    requestConfigWithTag(authToken, {
      name: "GET_User",
      path: "/api/v1/user",
    })
  );

  check(request, {
    "Successful Response": (r) => r.status === 200,
  });
  sleep(SLEEP_DURATION);
  return request.json().data.organization_id;
}

export function OrganizationCRUD(authToken) {
  return group("Organization_CRUD", () => {
    let size = "20"; // specify value as there is no example value for this parameter in OpenAPI spec
    let page = "1"; // specify value as there is no example value for this parameter in OpenAPI spec
    let organizationId = "";

    // Request No. 1: create_organization_api_v1_organization_post
    organizationId = createOrganization(authToken);

    // Request No. 2: get_organization_api_v1_organization_get
    {
      let url = BASE_URL + `/api/v1/organization?page=${page}&size=${size}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_Organizations",
          path: "/api/v1/organization?page=1&size=20",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });

      sleep(SLEEP_DURATION);
    }

    // Request No. 3: get_organization_by_id_api_v1_organization__organization_id__get
    {
      let url = BASE_URL + `/api/v1/organization/${organizationId}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_Organization",
          path: "/api/v1/organization/{organization_id}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });

      sleep(SLEEP_DURATION);
    }
    // Request No. 4: update_organization_api_v1_organization__organization_id__put
    {
      let url = BASE_URL + `/api/v1/organization/${organizationId}`;
      let body = {
        name: faker.company.companyName(),
        description: faker.lorem.sentence(),
      };
      let request = http.put(
        url,
        JSON.stringify(body),
        requestConfigWithTag(authToken, {
          name: "UPDATE_Organization",
          path: "/api/v1/organization/{organization_id}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
    }

    return organizationId;
  });
}

function createWorkspace(authToken, organizationId) {
  let url = BASE_URL + `/api/v1/organization/${organizationId}/workspace`;
  let body = {
    name: "workspace" + "_" + faker.lorem.word(10),
    description: faker.lorem.sentence(),
    isActive: true,
  };
  let request = http.post(
    url,
    JSON.stringify(body),
    requestConfigWithTag(authToken, {
      name: "CREATE_Workspace",
      path: "/api/v1/organization/{organization_id}/workspace",
    })
  );

  check(request, {
    "Successful Response": (r) => r.status === 200,
  });
  sleep(SLEEP_DURATION);
  return request.json().data.id;
}

export function WorkspaceCRUD(authToken) {
  return group("Workspace_CRUD", () => {
    let size = "20"; // specify value as there is no example value for this parameter in OpenAPI spec
    let page = "1"; // specify value as there is no example value for this parameter in OpenAPI spec
    let workspaceId = "";
    let organizationId = getUserOrganization(authToken);

    // Request No. 1: create_workspace_api_v1_organization__organization_id__workspace_post
    workspaceId = createWorkspace(authToken, organizationId);

    // Request No. 2: get_workspaces_api_v1_organization__organization_id__workspace_get
    {
      let url =
        BASE_URL +
        `/api/v1/organization/${organizationId}/workspace?page=${page}&size=${size}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_Workspaces",
          path: "/api/v1/organization/{organization_id}/workspace?page={page}&size={size}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });

      sleep(SLEEP_DURATION);
    }

    // Request No. 3: get_workspace_by_id_api_v1_organization__organization_id__workspace__workspace_id__get
    {
      let url =
        BASE_URL +
        `/api/v1/organization/${organizationId}/workspace/${workspaceId}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_Workspace",
          path: "/api/v1/organization/{organization_id}/workspace/{workspace_id}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });

      sleep(SLEEP_DURATION);
    }

    // Request No. 4: delete_workspace_api_v1_organization__organization_id__workspace__workspace_id__delete
    {
      let url =
        BASE_URL +
        `/api/v1/organization/${organizationId}/workspace/${workspaceId}`;

      let request = http.del(
        url,
        {},
        requestConfigWithTag(authToken, {
          name: "DELETE_Workspace",
          path: "/api/v1/organization/{organization_id}/workspace/{workspace_id}",
        })
      );
      // console.log(`response:${request.json()}`);
      // console.log(`response.status:${request.status}`);
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
    }

    return workspaceId;
  });
}

function createDataset(authToken, workspaceId, fileIds = []) {
  let url = BASE_URL + `/api/v1/workspace/${workspaceId}/dataset`;
  // console.log(fileIds);
  let body = {
    name: "dataset" + "_" + faker.lorem.word(10),
    description: faker.lorem.sentence(),
    file_ids: fileIds,
  };
  let request = http.post(
    url,
    JSON.stringify(body),
    requestConfigWithTag(authToken, {
      name: "CREATE_Dataset",
      path: "/api/v1/workspace/{workspace_id}/dataset/{dataset_id}",
    })
  );

  check(request, {
    "Successful Response": (r) => r.status === 200,
  });
  return request.json().data.id;
}

export function DatasetCRUD(authToken) {
  return group("DatasetCRUD", () => {
    let workspaceId = createWorkspace(authToken, getUserOrganization(authToken));
    let datasetId = "";

    // Request No. 1: create_dataset_api_v1_workspace__workspace_id__dataset_post
    datasetId = createDataset(authToken, workspaceId);

    // Request No. 2: get_dataset_api_v1_workspace__workspace_id__dataset__dataset_id__get
    {
      let url =
        BASE_URL + `/api/v1/workspace/${workspaceId}/dataset/${datasetId}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_Dataset",
          path: "/api/v1/workspace/{workspaceId}/dataset/{datasetId}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });

      sleep(SLEEP_DURATION);
    }

    // Request No. 3: update_dataset_api_v1_workspace__workspace_id__dataset__dataset_id__put
    {
      let url =
        BASE_URL + `/api/v1/workspace/${workspaceId}/dataset/${datasetId}`;
      // TODO: edit the parameters of the request body.
      let body = {
        name: "dataset" + "_" + faker.lorem.word(10),
        description: faker.lorem.sentence(),
        fileIds: [],
      };
      let request = http.put(
        url,
        JSON.stringify(body),
        requestConfigWithTag(authToken, {
          name: "UPDATE_Dataset",
          path: "/api/v1/workspace/{workspaceId}/dataset/{datasetId}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });

      sleep(SLEEP_DURATION);
    }

    // Request No. 4: delete_dataset_api_v1_workspace__workspace_id__dataset__dataset_id__delete
    {
      let url =
        BASE_URL + `/api/v1/workspace/${workspaceId}/dataset/${datasetId}`;
      let request = http.del(
        url,
        {},
        requestConfigWithTag(authToken, {
          name: "DELETE_Dataset",
          path: "/api/v1/workspace/{workspaceId}/dataset/{datasetId}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
    }

    // Request No. 5: get_datasets_api_v1_workspace__workspace_id__dataset_get
    {
      const page = 1;
      const size = 20;
      let url =
        BASE_URL +
        `/api/v1/workspace/${workspaceId}/dataset?page=${page}&size=${size}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_Datasets",
          path: "/api/v1/workspace/{workspaceId}/dataset/{datasetId}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });

      sleep(SLEEP_DURATION);
    }
    return datasetId;
  });
}

function createSourceConnector(authToken, workspaceId) {
  let url = BASE_URL + `/api/v1/workspace/${workspaceId}/source`;
  let body = {
    source_type: "azure_storage",
    container_name: "Test",
    sas_url: encoding.b64encode(
      "https://my.blob.core.windows.net/target/try/Target-Spanish.docx?sv=2019-12-12&st=2021-01-26T18%3A31%3A11Z&se=2021-02-05T18%3A31%3A00Z&sr=c&sp=wl&sig=AgddSzXLXwHKpGHr7wALt2DGQJHCzNFF%2F3L94JHAWZM%3D"
    ),
  };
  let request = http.post(
    url,
    JSON.stringify(body),
    requestConfigWithTag(authToken, {
      name: "CREATE_SourceConnector",
      path: "/api/v1/workspace/${workspaceId}/source",
    })
  );

  check(request, {
    "Successful Response": (r) => r.status === 200,
  });
  sleep(SLEEP_DURATION);
  return request.json().data.id;
}

export function SourceCRUD(authToken) {
  group("SourceCRUD", () => {
    const size = "10"; // specify value as there is no example value for this parameter in OpenAPI spec
    const page = "1"; // specify value as there is no example value for this parameter in OpenAPI spec
    const organizationId = getUserOrganization(authToken);
    const workspaceId = createWorkspace(authToken, organizationId);

    // Request No. 1: create_source_api_v1_workspace__workspace_id__source_post
    const sourceId = createSourceConnector(authToken, workspaceId);

    // Request No. 2: get_sources_api_v1_workspace__workspace_id__source_get
    {
      let url =
        BASE_URL +
        `/api/v1/workspace/${workspaceId}/source?page=${page}&size=${size}`;

      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_SourceConnectors",
          path: "/api/v1/workspace/${workspaceId}/source?page=${page}&size=${size}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });

      sleep(SLEEP_DURATION);
    }

    // Request No. 3: get_source_api_v1_workspace__workspace_id__source__source_id__get
    {
      let url =
        BASE_URL + `/api/v1/workspace/${workspaceId}/source/${sourceId}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_SourceConnector",
          path: "/api/v1/workspace/${workspaceId}/source/${sourceId}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });

      sleep(SLEEP_DURATION);
    }

    // Request No. 4: update_source_api_v1_workspace__workspace_id__source__source_id__put
    {
      let url =
        BASE_URL + `/api/v1/workspace/${workspaceId}/source/${sourceId}`;
      let body = {
        source_type: "azure_storage",
        container_name: "Test",
        sas_url: encoding.b64encode(
          "https://my.blob.core.windows.net/target/try/Target-Spanish.docx?sv=2019-12-12&st=2021-01-26T18%3A31%3A11Z&se=2021-02-05T18%3A31%3A00Z&sr=c&sp=wl&sig=AgddSzXLXwHKpGHr7wALt2DGQJHCzNFF%2F3L94JHAWZM%3D"
        ),
      };

      let request = http.put(
        url,
        JSON.stringify(body),
        requestConfigWithTag(authToken, {
          name: "UPDATE_SourceConnector",
          path: "/api/v1/workspace/${workspaceId}/source/${sourceId}",
        })
      );

      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
    }
  });
}

function createDestinationConnector(authToken, organizationId) {
  let url = BASE_URL + `/api/v1/organization/${organizationId}/destination`;
  let body = {
    name: "string",
    description: "string",
    is_active: true,
    pg_vector: {
      host: "amplifi",
      port: 5432,
      database_name: "amplifi_db",
      username: "amplifi123",
      password: "amplifi124",
    },
  };

  let request = http.post(
    url,
    JSON.stringify(body),
    requestConfigWithTag(authToken, {
      name: "CREATE_DestinationConnector",
      path: "/api/v1/organization/${organizationId}/destination",
    })
  );
  check(request, {
    "Successful Response": (r) => r.status === 200,
  });

  return request.json().data.id;
}

export function DestinationCRUD(authToken) {
  group("DestinationCRUD", () => {
    const organizationId = getUserOrganization(authToken);
    let size = "10"; // specify value as there is no example value for this parameter in OpenAPI spec
    let page = "1"; // specify value as there is no example value for this parameter in OpenAPI spec

    // Request No. 1: create_source_api_v1_workspace__workspace_id__source_post
    const destinationId = createDestinationConnector(authToken, organizationId);

    // Request No. 2: get_destinations_api_v1_organization__organization_id__destination_get
    {
      let url =
        BASE_URL +
        `/api/v1/organization/${organizationId}/destination?page=${page}&size=${size}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_DestinationConnectors",
          path: "/api/v1/organization/${organizationId}/destination?page=${page}&size=${size}",
        })
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
      sleep(SLEEP_DURATION);
    }
    // Request No. 3: get_destination_by_id_api_v1_organization__organization_id__destination__destination_id__get
    {
      let url =
        BASE_URL +
        `/api/v1/organization/${organizationId}/destination/${destinationId}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_DestinationConnector",
          path: "/api/v1/organization/${organizationId}/destination/${destinationId}",
        })
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
      sleep(SLEEP_DURATION);
    }
    // Request No. 4: delete_destination_api_v1_organization__organization_id__destination__destination_id__delete
    {
      let url =
        BASE_URL +
        `/api/v1/organization/${organizationId}/destination/${destinationId}`;
      let request = http.del(
        url,
        {},
        requestConfigWithTag(authToken, {
          name: "DELETE_DestinationConnector",
          path: "/api/v1/organization/${organizationId}/destination/${destinationId}",
        })
      );
      check(request, {
        "Successful Response": (r) => r.status === 204,
      });
    }
  });
}

export function UploadFile(authToken) {
  group("UploadFile", () => {
    const organizationId = getUserOrganization(authToken);
    const workspaceId = createWorkspace(authToken, organizationId);

    // Request No. 1: upload_file_api_v1_workspace__workspace_id__file_upload_post
    {
      let url = BASE_URL + `/api/v1/workspace/${workspaceId}/file_upload`;
      let body = {
        file: http.file(socratesFile, "Socrates.pdf"),
      };

      let request = http.post(
        url,
        body,
        requestConfigWithHeadersAndTag(
          authToken,
          {},
          {
            name: "POST_UploadFile",
            path: "/api/v1/workspace/${workspaceId}/file_upload",
          }
        )
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
      sleep(SLEEP_DURATION);
    }

    // Request No. 2: get_files_api_v1_workspace__workspace_id__file_get
    {
      const page = 1;
      const size = 10;
      let url =
        BASE_URL +
        `/api/v1/workspace/${workspaceId}/file?page=${page}&size=${size}`;

      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_Files",
          path: "/api/v1/workspace/${workspaceId}/file?order=page=${page}&size=${size}",
        })
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
    }
  });
}

export function IngestOneFile(authToken) {
  group("IngestOneFile", () => {
    let workspaceId = createWorkspace(authToken, getUserOrganization(authToken));

    let fileId = "";
    {
      let url = BASE_URL + `/api/v1/workspace/${workspaceId}/file_upload`;
      let body = {
        file: http.file(socratesFile, "Socrates.pdf"),
      };

      let request = http.post(
        url,
        body,
        requestConfigWithHeadersAndTag(
          authToken,
          {},
          {
            name: "POST_UploadFile",
            path: "/api/v1/workspace/${workspaceId}/file_upload",
          }
        )
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
      check(request.json().id, {
        "id is not null": (id) => id !== "" && id != null,
      });
      fileId = request.json().id;
      sleep(SLEEP_DURATION);
    }

    let datasetId = createDataset(authToken, workspaceId, [fileId]);
    let ingestionId = "";

    // Request No. 1: ingest_files_api_v1_dataset__dataset_id__ingest_post
    {
      let url = BASE_URL + `/api/v1/dataset/${datasetId}/ingest`;
      let body = { name: "IngestOneFile", metadata: {} };

      let request = http.post(
        url,
        JSON.stringify(body),
        requestConfigWithTag(authToken, {
          name: "POST_IngestFile",
          path: "/api/v1/dataset/${datasetId}/ingest",
        })
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
      console.log(`response:${JSON.stringify(request.json())}`);
      check(request.json().data[0].ingestion_id, {
        "ingestion_id is not null": (id) => id !== "" && id != null,
      });
      ingestionId = request.json().data[0].ingestion_id;
      if (ingestionId == "") {
        fail();
      }
      sleep(SLEEP_DURATION);
    }

    // Request No. 3: get_ingestion_status_api_v1_dataset__dataset_id__ingestion_status_get
    // {
    //   let url =
    //     BASE_URL +
    //     `/api/v1/dataset/${datasetId}/ingestion_status?ingestion_id=${ingestionId}`;
    //   let request = http.get(
    //     url,
    //     requestConfigWithTag(
    //       authToken,
    //       {
    //         name: "GET_IngestionStatus",
    //         path: "/api/v1/dataset/${datasetId}/ingestion_status?ingestion_id=${ingestionId}",
    //       }
    //     )
    //   );
    //   check(request, {
    //     "Successful Response": (r) => r.status === 200,
    //   });
    //   console.log(`response:${JSON.stringify(request.json())}`);
    // }
  });
}

export function GetAuditLogs(authToken) {
  group("GetAuditLogs", () => {
    const page = 1;
    const size = 50;
    const organizationId = getUserOrganization(authToken);
    const workspaceId = createWorkspace(authToken, organizationId);

    // Request No. 1: get_logs_api_v1_workspace__workspace_id__logs_get
    {
      let url =
        BASE_URL +
        `/api/v1/workspace/${workspaceId}/logs?page=${page}&size=${size}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_AuditLogs",
          path: "/api/v1/workspace/${workspaceId}/logs?page=${page}&size=${size}",
        })
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
    }
  });
}

function createWorkflow(
  authToken,
  organizationId,
  workspaceId,
  destinationId,
  datasetId
) {
  let url = BASE_URL + `/api/v1/organization/${organizationId}/workflow`;
  let body = {
    name: "Test Workflow",
    description: "string",
    is_active: true,
    workspace_id: workspaceId,
    destination_id: destinationId,
    dataset_id: datasetId,
    schedule_config: { cron_expression: "5 4 * * *" },
  };
  let request = http.post(
    url,
    JSON.stringify(body),
    requestConfigWithTag(authToken, {
      name: "CREATE_Workflow",
      path: "/api/v1/organization/${organizationId}/workflow",
    })
  );
  check(request, {
    "Successful Response": (r) => r.status === 200,
  });
  sleep(SLEEP_DURATION);
  return request.json().data.id;
}

export function WorkflowCRUD(authToken) {
  group("WorkflowCRUD", () => {
    const organizationId = getUserOrganization(authToken);
    const workspaceId = createWorkspace(authToken, organizationId);
    const datasetId = createDataset(authToken, workspaceId);
    const destinationId = createDestinationConnector(authToken, organizationId);

    const size = "10";
    const page = "1";

    // Request No. 1: add_workflow_into_organization_api_v1_organization__organization_id__workflow_post
    const workflowId = createWorkflow(
      authToken,
      organizationId,
      workspaceId,
      destinationId,
      datasetId
    );

    // Request No. 2: get_all_workflows_of_organization_api_v1_organization__organization_id__workflow_get
    {
      let url =
        BASE_URL +
        `/api/v1/organization/${organizationId}/workflow?page=${page}&size=${size}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_Workflows",
          path: "/api/v1/organization/${organizationId}/workflow?page=${page}&size=${size}",
        })
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
      sleep(SLEEP_DURATION);
    }

    // Request No. 3: get_workflow_by_id_api_v1_organization__organization_id__workflow__workflow_id__get
    {
      let url =
        BASE_URL +
        `/api/v1/organization/${organizationId}/workflow/${workflowId}`;
      let request = http.get(
        url,
        requestConfigWithTag(authToken, {
          name: "GET_Workflow",
          path: "/api/v1/organization/${organizationId}/workflow/${workflowId}",
        })
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
      sleep(SLEEP_DURATION);
    }
    // Request No. 4: update_workflow_api_v1_organization__organization_id__workflow__workflow_id__put
    {
      let url =
        BASE_URL +
        `/api/v1/organization/${organizationId}/workflow/${workflowId}`;
      // TODO: edit the parameters of the request body.
      let body = {
        name: "Test workflow",
        description: "Updated workflow",
        is_active: true,
        schedule_config: { cron_expression: "5 0 * 8 *" },
      };
      let request = http.put(
        url,
        JSON.stringify(body),
        requestConfigWithTag(authToken, {
          name: "Update_Workflow",
          path: "/api/v1/organization/${organizationId}/workflow/${workflowId}",
        })
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
      sleep(SLEEP_DURATION);
    }
    // Request No. 5: remove_workflow_api_v1_organization__organization_id__workflow__workflow_id__delete
    {
      let url =
        BASE_URL +
        `/api/v1/organization/${organizationId}/workflow/${workflowId}`;
      let request = http.del(
        url,
        {},
        requestConfigWithTag(authToken, {
          name: "DELETE_Workflow",
          path: "/api/v1/organization/${organizationId}/workflow/${workflowId}",
        })
      );
      check(request, {
        "Successful Response": (r) => r.status === 200,
      });
    }
  });
}

export function AllApis(authToken) {
  OrganizationCRUD(authToken)
  DatasetCRUD(authToken)
  DestinationCRUD(authToken)
  UsersList(authToken)
  SourceCRUD(authToken)
  UploadFile(authToken)
  WorkspaceCRUD(authToken)
  WorkflowCRUD(authToken)
  IngestOneFile(authToken)
  GetAuditLogs(authToken)
}

export default function (authToken) {
  // group("/api/v1/dataset/{dataset_id}/embedding_config", () => {
  //   let datasetId = "TODO_EDIT_THE_DATASET_ID"; // specify value as there is no example value for this parameter in OpenAPI spec
  //   // Request No. 1: create_embedding_config_api_v1_dataset__dataset_id__embedding_config_post
  //   {
  //     let url = BASE_URL + `/api/v1/dataset/${dataset_id}/embedding_config`;
  //     // TODO: edit the parameters of the request body.
  //     let body = {
  //       name: "string",
  //       isActive: "boolean",
  //       provider: "iembeddingproviderenum",
  //       baseModel: "string",
  //       baseDimension: "integer",
  //       batchSize: "integer",
  //       rerankModel: "string",
  //       addTitleAsPrefix: "boolean",
  //     };
  //     let params = {
  //       headers: {
  //         "Content-Type": "application/json",
  //         Accept: "application/json",
  //       },
  //     };
  //     let request = http.post(url, JSON.stringify(body), params);
  //     check(request, {
  //       "Successful Response": (r) => r.status === 200,
  //     });
  //   }
  // });
  // group("/api/v1/dataset/{dataset_id}/chunking_config", () => {
  //   let datasetId = "TODO_EDIT_THE_DATASET_ID"; // specify value as there is no example value for this parameter in OpenAPI spec
  //   // Request No. 1: add_chunking_config_into_a_dataset_api_v1_dataset__dataset_id__chunking_config_post
  //   {
  //     let url = BASE_URL + `/api/v1/dataset/${dataset_id}/chunking_config`;
  //     // TODO: edit the parameters of the request body.
  //     let body = {
  //       name: "string",
  //       provider: "string",
  //       chunkOverlap: "integer",
  //       maxChunkSize: "integer",
  //       strategy: "iunstructuredstrategyenum",
  //       chunkingStrategy: "iunstructuredchunkingstrategyenum",
  //       combineUnderNChars: "integer",
  //       maxCharacters: "integer",
  //       coordinates: "boolean",
  //       encoding: "string",
  //       extractImageBlockTypes: "list",
  //       gzUncompressedContentType: "string",
  //       hiResModelName: "string",
  //       includeOrigElements: "boolean",
  //       includePageBreaks: "boolean",
  //       languages: "list",
  //       multipageSections: "boolean",
  //       newAfterNChars: "integer",
  //       ocrLanguages: "list",
  //       outputFormat: "string",
  //       overlap: "integer",
  //       overlapAll: "boolean",
  //       pdfInferTableStructure: "boolean",
  //       similarityThreshold: "bigdecimal",
  //       skipInferTableTypes: "list",
  //       splitPdfConcurrencyLevel: "integer",
  //       splitPdfPage: "boolean",
  //       startingPageNumber: "integer",
  //       uniqueElementIds: "boolean",
  //       xmlKeepTags: "boolean",
  //       method: "ichunkingmethodenum",
  //       chunkSize: "integer",
  //     };
  //     let params = {
  //       headers: {
  //         "Content-Type": "application/json",
  //         Accept: "application/json",
  //       },
  //     };
  //     let request = http.post(url, JSON.stringify(body), params);
  //     check(request, {
  //       "Successful Response": (r) => r.status === 200,
  //     });
  //   }
  // });
  // group(
  //   "/api/v1/dataset/{dataset_id}/chunking_config/{chunking_config_id}",
  //   () => {
  //     let chunkingConfigId = "TODO_EDIT_THE_CHUNKING_CONFIG_ID"; // specify value as there is no example value for this parameter in OpenAPI spec
  //     let datasetId = "TODO_EDIT_THE_DATASET_ID"; // specify value as there is no example value for this parameter in OpenAPI spec
  //     // Request No. 1: get_chunking_config_by_id_api_v1_dataset__dataset_id__chunking_config__chunking_config_id__get
  //     {
  //       let url =
  //         BASE_URL +
  //         `/api/v1/dataset/${dataset_id}/chunking_config/${chunking_config_id}`;
  //       let request = http.get(url);
  //       check(request, {
  //         "Successful Response": (r) => r.status === 200,
  //       });
  //     }
  //   }
  // );
  // group("/api/v1/user/invite-user", () => {
  //   // Request No. 1: invite_user_api_v1_user_invite_user_post
  //   {
  //     let url = BASE_URL + `/api/v1/user/invite-user`;
  //     // TODO: edit the parameters of the request body.
  //     let body = {
  //       firstName: "string",
  //       lastName: "string",
  //       email: "string",
  //       role: "string",
  //       org: "string",
  //     };
  //     let params = {
  //       headers: {
  //         "Content-Type": "application/json",
  //         Accept: "application/json",
  //       },
  //     };
  //     let request = http.post(url, JSON.stringify(body), params);
  //     check(request, {
  //       "Successful Response": (r) => r.status === 200,
  //     });
  //   }
  // });
  // group("/api/v1/dataset/{dataset_id}/chunks", () => {
  //   let size = "TODO_EDIT_THE_SIZE"; // specify value as there is no example value for this parameter in OpenAPI spec
  //   let includeVectors = "TODO_EDIT_THE_INCLUDE_VECTORS"; // specify value as there is no example value for this parameter in OpenAPI spec
  //   let datasetId = "TODO_EDIT_THE_DATASET_ID"; // specify value as there is no example value for this parameter in OpenAPI spec
  //   let page = "TODO_EDIT_THE_PAGE"; // specify value as there is no example value for this parameter in OpenAPI spec
  //   let partialVectors = "TODO_EDIT_THE_PARTIAL_VECTORS"; // specify value as there is no example value for this parameter in OpenAPI spec
  //   let fileId = "TODO_EDIT_THE_FILE_ID"; // specify value as there is no example value for this parameter in OpenAPI spec
  //   // Request No. 1: get_chunks_api_v1_dataset__dataset_id__chunks_get
  //   {
  //     let url =
  //       BASE_URL +
  //       `/api/v1/dataset/${dataset_id}/chunks?file_id=${file_id}&include_vectors=${include_vectors}&partial_vectors=${partial_vectors}&page=${page}&size=${size}`;
  //     let request = http.get(url);
  //     check(request, {
  //       "Successful Response": (r) => r.status === 200,
  //     });
  //   }
  // });
  // group(
  //   "/api/v1/dataset/{dataset_id}/embedding_config/{embedding_config_id}",
  //   () => {
  //     let datasetId = "TODO_EDIT_THE_DATASET_ID"; // specify value as there is no example value for this parameter in OpenAPI spec
  //     let embeddingConfigId = "TODO_EDIT_THE_EMBEDDING_CONFIG_ID"; // specify value as there is no example value for this parameter in OpenAPI spec
  //     // Request No. 1: get_embedding_config_by_id_api_v1_dataset__dataset_id__embedding_config__embedding_config_id__get
  //     {
  //       let url =
  //         BASE_URL +
  //         `/api/v1/dataset/${dataset_id}/embedding_config/${embedding_config_id}`;
  //       let request = http.get(url);
  //       check(request, {
  //         "Successful Response": (r) => r.status === 200,
  //       });
  //       sleep(SLEEP_DURATION);
  //     }
  //     // Request No. 2: update_embedding_config_api_v1_dataset__dataset_id__embedding_config__embedding_config_id__put
  //     {
  //       let url =
  //         BASE_URL +
  //         `/api/v1/dataset/${dataset_id}/embedding_config/${embedding_config_id}`;
  //       // TODO: edit the parameters of the request body.
  //       let body = {
  //         name: "string",
  //         isActive: "boolean",
  //         provider: "iembeddingproviderenum",
  //         baseModel: "string",
  //         baseDimension: "integer",
  //         batchSize: "integer",
  //         rerankModel: "string",
  //         addTitleAsPrefix: "boolean",
  //       };
  //       let params = {
  //         headers: {
  //           "Content-Type": "application/json",
  //           Accept: "application/json",
  //         },
  //       };
  //       let request = http.put(url, JSON.stringify(body), params);
  //       check(request, {
  //         "Successful Response": (r) => r.status === 200,
  //       });
  //     }
  //   }
  // );
  // group("/api/v1/dataset/search", () => {
  //   // Request No. 1: start_eval_api_v1_dataset_search_post
  //   {
  //     let url = BASE_URL + `/api/v1/dataset/search`;
  //     // TODO: edit the parameters of the request body.
  //     let body = {
  //       query: "string",
  //       vectorSearchSettings: {
  //         searchLimit: "integer",
  //         searchIndexType: "string",
  //         probes: "integer",
  //         efSearch: "integer",
  //       },
  //       datasetIds: "list",
  //       searchMetrics: "boolean",
  //     };
  //     let params = {
  //       headers: {
  //         "Content-Type": "application/json",
  //         Accept: "application/json",
  //       },
  //       tags: {},
  //     };
  //     let request = http.post(url, JSON.stringify(body), params);
  //     check(request, {
  //       "Successful Response": (r) => r.status === 200,
  //     });
  //   }
  // });
}
